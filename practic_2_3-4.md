# ПРАКТИЧЕСКОЕ ЗАНЯТИЕ 3-4

## Встроенные функции для работы с массивами, функции для программирования без привязки к способу индексирования массива (0-based array или 1-based array)

- `eachindex`
- `enumerate`
- `begin`, `end`
- `first`, `firstindex`
- `last`, `lastindex`
  
## Встроенные функции для, используемые для обеспечения стабильности типов (type stable) переменных

- `typemin`, `typemax`
- `eltype`

## Простйшие однопроходные алгоритмы

Имеются следующие полезные  встроенные функции:

- `maximum`, `minnimum`
- `argmax`, `argmin`
- `findmax`, `findmin`
- `filter`

Примеры реализаций подобных функций:

```julia
function maximum_(A)
    M=typemin(eltype(A)) # такой способ инициализации обеспечивает стабильности типа переменной M
    for a in A
        M=max(M,a)
    end
    return M
end

function arg_max(a)
    i_max=firstindex(a) # такой способ инициализации обеспечивает независимость от фактического способа индесации (0-based или 1-based)
    for i in eachindex(a)
        if a[i]>a[i_max]
            i=i_max
        end
    end
    i_max
end

function find_max(A)
    i_max=arg_max(A)
    return (i_max, A[i_max])
end
```

Пример функции, возвращающей число максимальных элементов массива, реализующей однопроходный алгоритм:

```julia
function nummax(A)
    num=0
    M=typemin(eltype(A)) # такой способ инициализации обеспечивает стабильности типа переменной M
    for a in A
        if a == M
            num += 1
        elseif a>M
            num=1
            M=a
        end
    end
    return num
end

```

Задача 1. Написать функцию с заголовком `findallmax(A::AbstractArray)::AbstractArray{Int}`, возвращающую вектор индексов всех элементов массива A, имеющих максимальное значение. Алгоритм должен быть однопроходным, т.е. иметь асимптотическую оценку вычислительной сложности O(n).

## Усовершенствование пузырьковой сортировки

Во-первых, можно запоминать индекс последнего элемента с левого конца массива, на котором закнчиватся гарантированный правильный порядок следования элементов массимва, с тем, чтобы на следующей итерации можно было бы начитнать сразу с этой позиции.

Во-вторых, пузырьковую сортировку можно сделать так сказать двунаправленной, т.е. сначала очередной наибольший элемент премещать до своего окончательного положения влево, а затем, начиная с предыдущего ему элемента неремещать очередной наименьший элемент до конца влево. Такой способ сортировки принято называть еще "шенкерной" сортрирвкой. Наглядно это показано, например, [здесь](https://kvodo.ru/shaker-sort.html)

Задачи 2-3. Реализовать эти две разновидности пузырьковой сортировки.

## Сортировка Шелла

Сортировка Шелла состоит в следующем. Сначала упорядочиваются все элементы массива находящиеся через `n ÷ 2`  позиций(`n` - длина массива), затем - все элементы, стоящие через `n ÷ 4`, и т.д., и, наконец, все элементы стоящие через 1 позицию.

Наглядно это показано, например, [здесь](https://forkettle.ru/vidioteka/programmirovanie-i-set/algoritmy-i-struktury-dannykh/108-sortirovka-i-poisk-dlya-chajnikov/1008-sortirovka-shella)

## Сортировка выбором наибольшего (наименьшего) элемента

Идея сотрировки выбором отличается от сортировки методом пузырька лишь тем, что очередной максимальный элемент перемещается в конец массива не путем последовательности транспозиций с содними элементами, а сразу, после того, как сначала будет найден его индекс.

```julia
function exchangesort(a)
    for len in reverse(eachindex(a))
        i_max=arg_max(@view a[begin:len])
        a[i_max],a[len] = a[len],a[i_max]
    end
    return a
end
```

## Перестановка элементов в массиве без использования дополнительного массива

- срезы
- `permute!`

Пусть p - это некоторый вектор индексов массива A (одномерного, двумерного, или даже многомерного). Рассмотрим следующие примеры соответствующих срезов массива A (которые, напомним, получаются путем копирования элементов исходного массива):

```julia
B=A[p] # - если массив A одномерный
B=A[:, p] # - если A - это матрица
B=A[p, :]
```

Задача 4. Написать функцию с заголовком

```julia
slice(A::Vector{T},p::Vector{Int})::Vector{T} where T
```

возвращающую соответствующий срез неокоторого одномерного массива `A`.

Задача 5. Пусть `perm` - это некоторый вектор перестановок индексов одномерного массива `A`. Написать свою реализац
ию встроенной функции `permute!(A, perm)`, реализующую соответствующее премещение элементов массива `A` на месте (in-plice), т.е. без копирования их в новый массив . (Cвой вариант этой функции можно назвать `permute_!).

Указание. Если говорить алгебраическим языком, то, как известно, любая перестановка индексов представляется в виде произведения  некоторого числа независимых циклов (циклических перестановок). Понятно, что каждую такую независимую циклическую перестановку лего реализовать без использования дополнительного массива. Проблема состоит лишь в том, чтобы не пропустить никакую циклическую перестановку. Но для этого, при выполнении очередной циклической перестановки, можно,например, изменять знак каждого уже "использованного" индекса на отрицательный, и тогда, когда в векторе `perm` больше не останется положительных элементов, это будет означать, что все требуемые перестановки выполнены.

## Вставка/удаление/ элементов массива

- `deleteat!`, `insert!`
- `push!`, `pushfirst!`, `append!`
- `pop!`, `popfirst!`
- `resize!`

Задача 6. Реализовать встроенные функции вставки/добавления (deleteat!, insert!) элемента массива

## Выбор всех уникальных элементов массива

- `unique`
- `unique!`
- `allunique`
- `isequal`, `==`, `===`

Задача 7. Реализовать встроенные функции `unique`, `unique!`, `allunique`

## Обращение последовательности

- `reverse(a) = a[end:-1:begin]` # - это просто частный случай среза
- `reverse!`
- `reverseind(a,i)= lastindex(a)-i+firstindex(a)`
  
  
Задача 8. Реализовать встроенную функцию reverse!, переставляющую элементы в обратном порядке в самом массиве, т.е. "на месте"

## Сдвиг массива

Пусть имеется массив a=[a[1], a[2], ...,a[n]] и требуется сформировать массив, полученный из данного путем циклического сдвига на `m` позиций:

`[a[1+m],a[2+m],...,a[n], a[1], a[2], ...,a[m]]`.

Это можно было бы сделать, например, с помощью операции конкатенации:
`a=[a[1+m:end], a[1:m]]`
Это способ имеет недостаток, состоящий в том, что требует дополнительного расхода памяти (срезы придется где-то размещать в памяти, прежде чем они снова будут переписаны в объединенный массив).

Задача 9. Написать функцию, осуществляющую циклический сдвиг массива на m позиций "на месте", т.е. без использования дополнительного массива.

Указание. Для рещения задачи требуется знать соответствующую цепочку перемещений значений элементов массива. Для этого будет полезна функция (которую надо написать), получающая на вход некоторый индекс массива, и возвращающую другой его индекс - индекс позиции, с которой должен быть перемещен элемент массива на позицию с данным индексом. Эта функция будет иметь вид: nextindex(k::Int)=(k+m)%length(A), где % - операция взятия остатка от деления двух целых чисел (здесь функция nextindex рассматривается как замыкание переменной A).

## Размещение многомерного массива в памяти. Использование многомерного массива в качестве одномерного. Встроенная функция reshape

- `size`
- `length`
- `reshape`
- `getindex`
- `setindex!`

Любой многомерный массив (в частности, матрица) представляет собой соответствующую "обертку" некоторого одномерного массива (вектора), размещаемого в одномерной памяти (память компьютера имеет одномерную адресацию).
В частности, матрицы размещаются в памяти по столбцам: сначала первый столбец, следом за ним второй, и т.д.
Прэтому любой многомерный массив всегда может использоваться как одномерный (в случае матрицы этот одномерный массив будет как бы составлен из ее столбцов), т.е. для его элемнтов всегда можно использовать только один индекс.

Для лучшего понимания этого рассморим пример возможной реализации двумерных массивов.
  
```julia
struct Matrix_{T}<:AbstractVector
    vector::Vector{T}
    size::Tuple{Int,Int}
end

length(A::Matrix_)=prod(A.size)
size(A::Matrix_) = size(A.size)

reshape(A::Matrix_,size::Tuple{Int,Int})= (@assert prod(size)==length(A); A.size=size; return A)
reshape(A::Matrix_,size...)=reshape(A,size) # - чтобы можно было еще и так: reshape(A, m, n)

getindex(A::Matrix_,i) = A.vector[i] # чтобы можно было: A[i]
getindex(A::Matrix_,i,j) = A.vector[size[1]*(j-1)+i] # чтобы можно было: A[i,j]
setindex![A::Matrix_,val,i] = (A.vector[i]=val) # чтобы можно было: A[i]=...
setindex![A::Matrix_,val,i,j] = (A.vector[size[1]*(j-1)+i]=val) # чтобы можно было: A[i,j]=...

```

В действительности, в языке Julia двумерные и многомерные массивы изначально определены, поэтому приведенное определение как бы дублирует некоторые (далеко не все) встроенные возможности массивов Julia, и приведено здесь исключительно лишь для пояснения  того, что представляют собой многомерные массивы на более низком уровне.

ЗАМЕЧАНИЕ. В действительности, и любой одномерный массив также представляет собой некоторую структуру, содержащую ссылку на массив, а также число элементов в массиве (данного типа). Так что в случае одномерного массива встроенная функция `length` просто возвращает содержащееся в этой структуре число.

### Транспонирование матрицы

- `transpose(A)`, `A'` (если матрица A комплексная, то `A'=conj(transpse(A))`)
- `conj(A)` - возвращает комплексно0-сопряженную матрицу

Задача 10. Реализовать  функцию, аналогичную встроенной функции transpose, с использованием вспомогательного массива

Задача 11. Реализовать функцию, аналогичную встроенной функции transpose, осуществляющую транспонирование матрицы "на месте" (без использования вспомогательного массива)

Указание. Требуется найти все циклы перестановок индексов в одномрном массиве, передставляющем матрицу, при ее транспонировании, т.е. фактически требуется определить функцию, которая бы для каждого индекса соответствующего одномерного массива (представляющего матрицу) возвращала бы индекс другого его элемента, который должен быть перемещен на позицию с данным индексом. С помощью такой функции можно будет осуществить все необходимые циклические перестановки элементов в массиве. Если не брать в расчет матрицы, представляющие собой вектор-столбец или вектор-строку (тут вообще элементы перемещать не требуется), то проще всего транспонировать квадратную матрицу. В общем же случае прямоугольной матрицы определить все необходимые циклические перестановки более сложно, но возможно.

Далее, допустим, удалось в одномерном массиве, соответствующем прямоугольной матрице `A`, переставить элементы так, чтобы он соответствовал транспонированной матрице `A'`. Тогда необходимо еще будет выполнить еще процедуру: `A=reshape(A,reverse(siize(A)))`, которая просто в соответствующей (предполагаемой, см. выше) структуре изменит значение переменной `size` (в случае квадратной матрицы это делать не обязательно).
