# ПРАКТИЧЕСКОЕ ЗАНЯТИЕ 3-4

## Встроенные функции для работы с массивами, функции для программирования без привязки к способу индексирования массива

В одних языках программирования, таких как С, Python и многих других, индексация элементв массивов начинается с 0 (0-based array). В других языках, ориентированных на математические вычисления, таких как Fortran, Matlab/Octave, R, Julia, индексация массивов начинается с 1 (1-based array).

Однако, не смотря на то, что в Julia встроенные массивы индексируются с 1, в этом языке ещё имеется также возможность определять границы диапазона индексов произвольным образом; допускается использовать даже отрицательные значения индексов. Такие массивы представляют собой некоторую "обёртку" обычных массивов, и создаются с помощью специального конструктора `OffsetArray`, определённого в пакете `OffsetArrays.jl` (который требует предварительной установки).

Например, если имеется стандартный одномерный массив `A` некоторого типа, то можно создать новую **ссылку** (типа `OffsetArray`) на этот же самый массив, но с какими-то другими произвольно заданными границами индексов. Например, диапазон индексов `0:length(A)-1` следует задавать так:

```Julia
using OffsetArrays

B=OffsetArray(A, 0:length(A)-1)
```

Вообще, границы диапазона индексов могут быть любыми, лишь бы число индексов во всем диапазоне совпадало с длиной массива `A`.

В случае многомерных массивов - всё аналогично. Например, если `A` - это матрица (любого типа), то изменить пределы индексирования в ней можно в частности так:

```julia
A=OffsetArray(A, 0:size(A,1), -2:size(A,2)-3)
```

т.е. по разным измерениям массива пределы индексирования могут различными.

Для того, чтобы можно было программировать обобщённо, не опираясь явно на тот или иной способ индексирования массивов, в языке Julia предусмотрены следующие функции и зарезервированные слова:

- `eachindex`
- `enumerate`
- `first`, `firstindex`
- `last`, `lastindex`
- `begin`, `end` - в контексте индексного выражения эти слова заменяют собой значение первого и последнего индекса, соответственно.
При этом

```julia
first(A)=A[begin]
last(A)=A[end] 
```

## Встроенные функции, используемые для обеспечения стабильности типов (type stable) переменных

- `typemin`, `typemax` - возвращают предельные значения заданного типа
- `eltype` - возвращает тип **элеметов** заданного массива (может применяться и к скалярным значениям; имеется еще встроенная функция `typeof`, возвращающая тип своего аргумента, но это другая функция, не заменяющая данную).

Примеры использования такого рода функций в конкретном коде имеются ниже.

## Простйшие однопроходные алгоритмы

Имеются следующие полезные  встроенные функции:

- `maximum`, `minnimum`
- `argmax`, `argmin`
- `findmin`, `findmax`, `findmin!`, `findmax!`
- `findall`, `findprev`, `findnext`,  `findlast`, `findfirst`
- `filter`

Примеры реализаций подобных функций:

```julia
function maximum_(A)
    M=typemin(eltype(A)) # такой способ инициализации обеспечивает стабильности типа переменной M
    for a in A
        M=max(M,a)
    end
    return M
end

function arg_max(a)
    i_max=firstindex(a) # такой способ инициализации обеспечивает независимость от фактического способа индесации (0-based или 1-based)
    for i in eachindex(a)
        if a[i]>a[i_max]
            i=i_max
        end
    end
    i_max
end

function find_max(A)
    i_max=arg_max(A)
    return (i_max, A[i_max])
end
```

Число максимальных элементов в массиве - это пример не индуктивной функции на последовательностях. В самом деле, если известно число максимумов в некоторой начальной части массива и получен еще один элемент последовательности, то по этим данным невозможно однозначно определить, сколько же теперь получилось максимумов.  Для вычисления такой функции за один проход требуется найти какое-либо ее индуктивное расширение. Таким индуктивным расширением в данном случае может быть пара: (максимальное_значение, число_максимумов).
Тогда реализация соответствующего однопроходного алгоритма может выглядеть так:

```julia
function nummax(A)
    num=0
    M=typemin(eltype(A)) # такой способ инициализации обеспечивает стабильности типа переменной M
    for a in A
        if a == M
            num += 1
        elseif a>M
            num=1
            M=a
        end
    end
    return num
end
```

Задача 1. Написать функцию с заголовком `findallmax(A::AbstractVector)::AbstractVector{Int}`, возвращающую вектор индексов всех элементов массива `A`, имеющих максимальное значение. Алгоритм должен быть однопроходным, т.е. иметь асимптотическую оценку вычислительной сложности `O(n)`.

Указание. Убедиться, что вектор индексов максимальных элементов массива является не индуктивной функцией на последовательностях и найти подходящее её индуктивное рысширение.

Решение.

Вариант с динамически изменящимся размером формируемого массива индексов, с привязкой к способу индексации (1-based arrays):

```julia
function find_all_max(a)
    i_max=[1]
    for i in 2:length(a)
        if A[i]>A[i_max[end]]
            i_max=[i]
        elseif A[i]==A[i_max[end]]
            push!(i_max, i)
        end
    end
    return i_max
end
```

Более предпочтительный вариант без привязки к способу индексации:

```julia
"""
    find_all_max(a)

-- возвращает массив с индексами элементов коллекции a, имеющих максимальное значение 
 (Вариант с использованием push!, без приязки к способу индексации массива)
"""
 function find_all_max(a)
    i_max=[firstindex(a)]
    for i in firstindex(a)+1:lastindex(a)
        if A[i]>A[i_max[end]]
            i_max=[i]
        elseif A[i]==A[i_max[end]]
            push!(i_max, i)
        end
    end
    return i_max
end
```

Еще более предпочтительный вариант без приязки к способу индексации массива и без динамического расширения формируемого массива индексов, т.е. без push!:

```julia
function find_all_max(a)
    i_max=Vector{Int}(undef,size(a))
    i_max[begin]=firstindex(a)
    n = firstindex(i_max)
    for i in firstindex(a)+1:lastindex(a)
        if A[i]>A[i_max[end]]
            i_max[begin]=i
            n = firstindex(i_max)
        elseif A[i]==A[i_max[end]]
            n+=1
            i_max[n]=i
        end
    end
    return resize!(i_max,n)
end
```

## Усовершенствование пузырьковой сортировки

Во-первых, можно запоминать индекс последнего элемента с левого конца массива, на котором закнчиватся гарантированный правильный порядок следования элементов массимва, с тем, чтобы на следующей итерации можно было бы начитнать сразу с этой позиции.

Во-вторых, пузырьковую сортировку можно сделать, так сказать, двунаправленной, т.е. сначала очередной наибольший элемент премещать до своего окончательного положения влево, а затем, начиная с предыдущего ему элемента перемещать очередной наименьший элемент до конца влево. Такой способ сортировки принято называть еще "шенкерной" сортрирвкой. Наглядно это показано, например, [здесь](https://kvodo.ru/shaker-sort.html)

Задачи 2-3. Реализовать эти две разновидности пузырьковой сортировки.

## Сортировка Шелла

Сортировка Шелла состоит в следующем. Сначала, с использованием (по существу) алгоритма сотировки вставками (без бинарного поиска), упорядочиваются все элементы массива находящиеся через `n ÷ 2`  позиций , затем - все элементы, стоящие через `n ÷ 4`, и т.д., и, наконец, все элементы стоящие через 1 позицию (`n` - длина массива).  Поэтому весь массив оказывается отсортированным (последний раз, при шаге выбора, равном 1, была фактически выполна сортировка вставками всего массива; однако благодаря предыдущим частичным сортировкам массива, перестановок соседних элементов в нем потребовалось сделать уже совсем не много).

Наглядно это показано, например, [здесь](https://forkettle.ru/vidioteka/programmirovanie-i-set/algoritmy-i-struktury-dannykh/108-sortirovka-i-poisk-dlya-chajnikov/1008-sortirovka-shella)

Таким образом в классическом алгоритме Шелла используется последовательность промежутков, равных $n\div 2^i$, где $i = 1,2,...,k$, $k=floor(log_2(n))$ - наибольшее натуральное число, такое что $2^k \le n$. 

```julia
function shellsort!(a)
    n=length(a)
    distseries=(n÷2^i for i in 1:Int(floor(log2(n)))) 
    # distseries - это ГЕНЕРАТОР последовательности промежутков (т.е. члены этой последовательности будут вычисляться в процессе выполнения следующего цикла, заранее в памяти они не размещаются, как было бы при использовании массива или кортежа вместо генератора)
    for d in distseries
        for i in firstindex(a):lastindex(a)-d
            j=i
            while j>=firstindex(a) && a[j]>a[j+d]
                a[j],a[j+d] = a[j+d],a[j]
                j-=d
            end
        end
    end
    return a
end
```

ЗАМЕЧАНИЕ. В приведенном коде можно было бы обойтись без использования генератора `distseries`, вычисляя очередное значение промежутка `d` во внешнем цикле. Но использование генератора делает код более читаемым, разделяя процесс вычисления очередного значения `d` и всего остального. Вместе с тем, использование для этой цели именно генератора, а не массива, позволяет исключить дополнительное расходование ресурса памяти.

По-существу то же самое (несколько изменив порядок сравнения пар) можно записать еще и так:

```julia
function shellsort!(a)
    n=length(a)
    distseries=(n÷2^i for i in 1:Int(floor(log2(n)))) 
    for d in distseries
        for i in firstindex(a):d-1
            insertsort!(@view a[i:d:end]) # - сортировка вставками выделенного (прореженного) подмассива
        end
    end
    return a
end
```

Рассмотренный алгритм сортировки имеет оценку вычислительной сложности $O(n^2)$. Однако известны другие способы выбора последовательности величин промежутков, позволяющие понизить порядок ассимптотической оценки вычислительной сложности этого алгоритма, см., например, [здесь](https://ru.wikipedia.org/wiki/Сортировка_Шелла).

Поскольку эффективность алгоритма Шелла зависит от последовательности значений промежутков, то (в исследовательских целях) имеет смысл в функции `shellsort` generator последовательности промежутков сделать параметром фцнкции:

```julia
function shellsort!(a; distseries::Function=(length(a)÷2^i for i in 1:Int(floor(log2(length(a))))))
    for d in distseries
        for i in firstindex(a):lastindex(a)-d
            j=i
            while j>=firstindex(a) && a[j]>a[j+d]
                a[j],a[j+d] = a[j+d],a[j]
                j-=d
            end
        end
    end
    return a
end
```

Задача 4. Реализовать сортировку Шелла и проверить работоспособность алгоритма при следующих наборах значений промежутков:

- $d \in \{d_i |i \in \N\, d_1 = n/2$ , $d_i = d_{i−1}/2\}$ (обеспечивается оценка сложности $O(n^2)$)
- $d \in \{2^i-1\le n, i∈\N\}$ (обеспечивается оценка сложности $O(n^\frac{3}{2})$);
- $d\in\{d_i | i \in\N\cup\{0\}\}$, где для четных $i$ $d_i = 9⋅2^i − 9⋅2^\frac{i}{2} + 1$, а для нечетных - $d_i = 8⋅2^i − 6⋅2^\frac{i+1}{2} + 1$  (обеспечивается оценка сложности $O(n^\frac{7}{6})$ в среднем);
- $d \in \{2^i⋅3^j ≤ n/2, i,j \in \N \}$,  (обеспечивается оценка сложности $O(n \cdot \log^{2}n)$);
- $d \in \{1,4,10,23,57,132,301,701,1750 \}$ (считается, что такой набор промежутков является одним из лучших для сортировки массива размером приблизительно до 4000 элементов);
- $d ∈ \{F_i | i \in \N\cup\{0\}\}$, $F_i$ - $i$-ое число Фибоначчи;
- $d \in \{(3^j − 1) ≤ n, j\in \N\}$ (обеспечивается оценка сложности $O(n^\frac{3}{2})$).

Указание. При создании соответствующего генератора (перед передачей его в функцию через соответствующий именованный параметр) требуется обеспечить, чтобы элементы соответствующих множеств перебирались в порядке от больших значений к меньшим.
Для исследования эффективности того или иного алгоритма сортировки требуется выполнять оценки его времени выполнения (см. ниже) на достаточно большом массиве (содержащем многие тысячи и десятки тысяч элементов и более). Для генерации таких массивов следует использовать встроенные функции `rand` или `randn` предназначенные для генерации псевдослучайных массивов заданного типа и заданных размеров.

## Оценка времени выполнения программы (benchmark)

Для оценивания времени выполнеия программы (функции) в языке Julia имеется специальный макрос `@time`. Например, с эго помощью можно выполнить замеры времени сортирвки с помощь встроенной функции `sort`:

```julia
julia> @time sort([1,2,1,6,1,3]);
  0.000003 seconds (2 allocations: 256 bytes)

julia> @time sort([1,2,1,6,1,3]);
  0.000003 seconds (2 allocations: 256 bytes)

julia> @time sort([1,2,1,6,1,3]);
  0.000004 seconds (2 allocations: 256 bytes)

julia> @time sort([1,2,1,6,1,3]);
  0.000006 seconds (2 allocations: 256 bytes)

julia> @time sort([1,2,1,6,1,3]);
  0.000004 seconds (2 allocations: 256 bytes)
```

ЗАМЕЧАНИЕ. Как видно несколько замеров времени выполнения одного и того же кода могут давать несколько разные результаты. Это связано с тем, что используемая операционная система является многозадачной, т.е. под её управлением практически всегда выполняется сразу несколько приложений, как бы одновременно, т.е. опрерационная система по некоторому правилу сама передает управление то одной, то другой выполняемой задаче (обеспечивая видимость их одновременного выполнения). Таким образом, при временных замерах всегда будет присутствовать вызванный этим случайный фактор.
Поэтому, для обеспечения более точного значения времени выполнения программы требуется выполнять замеры многократно, и выбирать из них наименьшую оценку времени выполнеия. Для это существут специальный макрос @btime, который однако требуется импортировать из пакета `BenchmarkTools.jl`, который требует предварительной установки. Примеры использовании этого пакета можно посмотреть [здесь](https://github.com/JuliaCI/BenchmarkTools.jl)

## Сортировка выбором наибольшего (наименьшего) элемента

Идея сотрировки выбором отличается от сортировки методом пузырька лишь тем, что очередной максимальный элемент перемещается в конец массива не путем последовательности транспозиций с содними элементами, а сразу, после того, как сначала будет найден его индекс.

```julia
function exchangesort(a)
    for len in reverse(eachindex(a))
        i_max=arg_max(@view a[begin:len])
        a[i_max],a[len] = a[len],a[i_max]
    end
    return a
end
```

## Перестановка элементов в массиве без использования дополнительного массива

- срезы
- `permute!`

Пусть p - это некоторый вектор индексов массива A (одномерного, двумерного, или даже многомерного). Рассмотрим следующие примеры соответствующих срезов массива A (которые, напомним, получаются путем копирования элементов исходного массива):

```julia
B=A[p] # - если массив A одномерный
B=A[:, p] # - если A - это матрица
B=A[p, :]
```

Задача 5. Написать функцию с заголовком

```julia
slice(A::Vector{T},p::Vector{Int})::Vector{T} where T
```

возвращающую соответствующий срез неокоторого одномерного массива `A`.

Задача 6. Пусть `perm` - это некоторый вектор перестановок индексов одномерного массива `A`. Написать свою реализац
ию встроенной функции `permute!(A, perm)`, реализующую соответствующее премещение элементов массива `A` на месте (in-plice), т.е. без копирования их в новый массив . (Cвой вариант этой функции можно назвать `permute_!).

Указание. Если говорить алгебраическим языком, то, как известно, любая перестановка индексов представляется в виде произведения  некоторого числа независимых циклов (циклических перестановок). Понятно, что каждую такую независимую циклическую перестановку лего реализовать без использования дополнительного массива. Проблема состоит лишь в том, чтобы не пропустить никакую циклическую перестановку. Но для этого, при выполнении очередной циклической перестановки, можно,например, изменять знак каждого уже "использованного" индекса на отрицательный, и тогда, когда в векторе `perm` больше не останется положительных элементов, это будет означать, что все требуемые перестановки выполнены.

## Вставка/удаление/ элементов массива

- `deleteat!`, `insert!`
- `push!`, `pushfirst!`, `append!`
- `pop!`, `popfirst!`
- `resize!`

Задача 7. Реализовать встроенные функции вставки/добавления (deleteat!, insert!) элемента массива

## Выбор всех уникальных элементов массива

- `unique`
- `unique!`
- `allunique`
- `isequal`, `==`, `===`

Задача 8. Реализовать встроенные функции `unique` (возвращает новый массив, в который каждый элемент исходного массива входит только по одному разу), `unique!` (удаляет из исходного массива повторяющиеся элементы, оставляя каждый элемент в единственном экземпляре), `allunique` (проверяет, состоит ли данный массив только из уникальных элементов). Для функций `unique` и `unique!` обеспечить асимптотическую оценку вычислительной сложности `O(n*log(n))`.

Указание. Воспользоваться встроенной функцией `sort` (или `sort!`), которая по умолчанию реализует "быструю" сортировку, т.е. c оценкой вычислительной сложности `O(n*log(n)) (в среднем).

## Обращение последовательности

- `reverse(a) = a[end:-1:begin]` - это просто частный случай среза
- `reverse!` - переставляет элементы "на месте", т.е. без использования второго массива
- `reverseind(a,i)= lastindex(a)-i+firstindex(a)`
  
Задача 9. Реализовать встроенную функцию reverse!, переставляющую элементы в обратном порядке в самом массиве, т.е. "на месте"

## Сдвиг массива

Пусть имеется массив a=[a[1], a[2], ...,a[n]] и требуется сформировать массив, полученный из данного путем циклического сдвига на `m` позиций:

`[a[1+m],a[2+m],...,a[n], a[1], a[2], ...,a[m]]`.

Это можно было бы сделать, например, с помощью операции конкатенации:
`a=[a[1+m:end], a[1:m]]`
Это способ имеет недостаток, состоящий в том, что требует дополнительного расхода памяти (срезы придется где-то размещать в памяти, прежде чем они снова будут переписаны в объединенный массив).

Задача 10. Написать функцию, осуществляющую циклический сдвиг массива на `m` позиций "на месте", т.е. без использования дополнительного массива.

Указание. Для рещения задачи требуется знать соответствующую цепочку перемещений значений элементов массива. Для этого будет полезна функция (которую надо написать), получающая на вход некоторый индекс массива, и возвращающую другой его индекс - индекс позиции, с которой должен быть перемещен элемент массива на позицию с данным индексом. Эта функция будет иметь вид: `nextindex(k::Int)=(k+m)%length(A)`, где `%` - операция взятия остатка от деления двух целых чисел (здесь функция nextindex рассматривается как замыкание переменной `A`).

Имеется еще один способ получения циклического сдвига массива за $O(n)$ действий:

```julia
function cyclshift(a::AbstractVector, k::Int) 
    reverse!(a)
    reverse!(@view a[begin:begin+k])
    reverse!(@view a[begin+k+1:end])
end
```

## Размещение многомерного массива в памяти. Использование многомерного массива в качестве одномерного. Встроенная функция reshape

- `size`
- `length`
- `ndims`
- `reshape`
- `getindex`
- `setindex!`

Любой многомерный массив (в частности, матрица) представляет собой соответствующую "обертку" некоторого одномерного массива (вектора), размещаемого в одномерной памяти (память компьютера имеет одномерную адресацию).
В частности, матрицы размещаются в памяти по столбцам: сначала первый столбец, следом за ним второй, и т.д.
Прэтому любой многомерный массив всегда может использоваться как одномерный (в случае матрицы этот одномерный массив будет как бы составлен из ее столбцов), т.е. для его элемнтов всегда можно использовать только один индекс.

Для лучшего понимания этого рассморим пример возможной реализации двумерных массивов.
  
```julia
struct Matrix_{T}<:AbstractVector
    vector::Vector{T}
    size::Tuple{Int,Int}
end

length(A::Matrix_) = prod(A.size)
size(A::Matrix_) = size(A.size)

reshape(A::Matrix_,size::Tuple{Int,Int})= (@assert prod(size)==length(A); A.size=size; return A)
reshape(A::Matrix_,size...)=reshape(A,size) # - чтобы можно было еще и так: reshape(A, m, n)

getindex(A::Matrix_,i) = A.vector[i] # чтобы можно было: A[i]
getindex(A::Matrix_,i,j) = A.vector[size[1]*(j-1)+i] # чтобы можно было: A[i,j]
setindex![A::Matrix_,val,i] = (A.vector[i]=val) # чтобы можно было: A[i]=...
setindex![A::Matrix_,val,i,j] = (A.vector[size[1]*(j-1)+i]=val) # чтобы можно было: A[i,j]=...
```

В действительности, в языке Julia двумерные и многомерные массивы определены изначально, поэтому приведенное определение для практических вычислений не требуется (оно дублирует встроенные возможности языка), и дано здесь лишь для пояснения того, что же представляют собой многомерные массивы на более низком уровне.

ЗАМЕЧАНИЕ. В действительности, и любой одномерный массив также представляет собой некоторую структуру, содержащую ссылку на массив, а также число элементов в массиве (данного типа). Так что в случае одномерного массива встроенная функция `length` просто возвращает содержащееся в этой структуре число.

### Транспонирование матрицы

- `transpose(A)`, `A'` (если матрица A комплексная, то `A'=conj(transpse(A))`)
- `conj(A)` - возвращает комплексно0-сопряженную матрицу

Задача 11. Реализовать  функцию, аналогичную встроенной функции transpose, с использованием вспомогательного массива

Задача 12. Реализовать функцию, аналогичную встроенной функции transpose, осуществляющую транспонирование матрицы "на месте" (без использования вспомогательного массива)

Указание. Требуется найти все циклы перестановок индексов в одномрном массиве, передставляющем матрицу, при ее транспонировании, т.е. фактически требуется определить функцию, которая бы для каждого индекса соответствующего одномерного массива (представляющего матрицу) возвращала бы индекс другого его элемента, который должен быть перемещен на позицию с данным индексом. С помощью такой функции можно будет осуществить все необходимые циклические перестановки элементов в массиве. Если не брать в расчет матрицы, представляющие собой вектор-столбец или вектор-строку (тут вообще элементы перемещать не требуется), то проще всего транспонировать квадратную матрицу. В общем же случае прямоугольной матрицы определить все необходимые циклические перестановки более сложно, но возможно.

Далее, допустим, удалось в одномерном массиве, соответствующем прямоугольной матрице `A`, переставить элементы так, чтобы он соответствовал транспонированной матрице `A'`. Тогда дополнительно необходимо будет еще выполнить процедуру: `A=reshape(A,reverse(siize(A)))`, которая просто в соответствующей (предполагаемой, см. выше) структуре изменит значение переменной `size` (в случае квадратной матрицы это делать не обязательно).
