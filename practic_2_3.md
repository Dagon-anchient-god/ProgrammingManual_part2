# ПРАКТИЧЕСКОЕ ЗАНЯТИЕ 3

ЗАМЕЧАНИЕ. Поскольку срез матрицы в виде ее строки - это в формальном отношении двумерный а не одномерный массив, то для сортировки строк матрицы мезанизм множественной диспетчеризации работать не будет (вместо этого возникнет рекурсия). Поэтому, для того чтобы аналогичным образом сортировать сторки матрицы, ее сначала нужно транспонировать, затем использовать сортировку столбцов, затем снова транспонировать.

Задача: реализовать функцию, выполняющую транспонирование (transpose - соответствующая встроенная функция julia)
(Указание: сначала разобраться с алгоритмом перестановки элементов одномерного массива в обратном порядке. В julia имеется соответствующая встроенная функция - reverse)

## Перестановка элементов в массиве без использования дополнительного массива

Пусть имеется  некоторый одномерный массива `A`, и требуется переставить элементы `A` в порядке, определяемом вектором заданной перестановки его индексов `indperm`.

Для этого в Julia можно просто написать `A[indperm]`, чем ранее мы уже воспользовались. Однако возникает вопрос, а как это реализуется на более низком уровне?

В принципе это можно сделать следующими  двумя способами:

- копировать элементы исходного массива `A` в новый массив `B` в требуемом порядке, определяемом вектором индексов indperm, а затем присвоить `A=B`
- переставлять элементы непосредственно в массиве `A`, не используюя дополнительного массива `B`
  
Второй способ позволяет не расходовать дополнительную память (для больших массивов это может быть критично).

Какой из этих двух способов реализован в Julia - этот вопрос требует специального исследования. Скорее всего, реализован первый способ, поскольку срезы допускают не только перестановку индексов. В частности индексы в наборе могут быть повторящимися, а в этом случае речь не может идти только о циклических перестановках сответствующих значений в массиве. При этом проверка, является ли данный набор индексов некоторой перестановкой индексов исходного массива или нет, реализуется на основе сортировки, т.е. является довольно затратной.

Задача: реализовать этот второй способ перестановки элементов массива.

Указание. Если говорить алгебраическим языком, то, как известно, любая перестановка индексов представляется в виде произведения  некоторого числа независимых циклов (циклических перестановок). Понятно, что каждую такую независимую циклическую перестановку лего реализовать без использования дополнительного массива. Проблема состоит лишь в том, чтобы не пропустить никакую циклическую перестановку. Но для этого, при выполнении очередной циклической перестановки, можно,например, изменять знак каждого уже "использованного" индекса на отрицательный, и тогда, когда в векторе `indperm` больше не останется положительных элементов, это будет означать, что все требуемые перестановки выполнены.

