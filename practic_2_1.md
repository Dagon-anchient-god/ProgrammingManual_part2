# ПРАКТИКОЕ ЗАНЯТИЕ 1

## Функции сортировки в Julia

Изучить с помощью встроенной помощи (help?>) назначение и способы использования следующих встроенных функций julia:

- sort!(a), sort(a), sortperm!(a), sortperm(a)
- issorted
- zeros
- size, length
- findall, finfirst
- collect
- view, @view
- Array, Vector, Matrix
- similar
- eltype
- copy, deepcopy

- firs, firstindex, last, lastindex, nextindex
- begin, end - в контексте индексного выражения обозначают первый и последний индекс массива, соответственно (вне зависимости от типа индексации данного массива)

## Сортирвка методом "пузырька"

По аналогии со встроенными функциями сортировки можно реализовать следующие 4 вида функций сортировки на базе агоритма сортировки методом "пузырька".

```julia
function bubblesort!(a)
    n = length(a)
    for k in 1:n-1
        istranspose = false
        for i in 1:n-k
            if a[i]>a[i+1]
                a[i], a[i+1] = a[i+1], a[i]
                istranspose = true
            end
        end
        if istranspose == false
            break
        end
    end
    return a
end
```

```julia
bubblesort(a)=bubblesort!(deepcopy(a))
```

```julia
function bubblesortperm!(a)
    n = length(a)
    indexes = collect(1:n)
    for k in 1:n-1
        istranspose = false
        for i in 1:n-k
            if a[i]>a[i+1]
                a[i],a[i+1]=a[i+1],a[i]
                indexes[i],indexes[i+1]=indexes[i+1],indexes[i]
                istranspose = true
            end
        end
        if istranspose == false
            break
        end
    end
    return indexes
end
```

```julia
bubblesortperm(a)=bubblesortperm!(deepcopy(a))
```

## Способ программирования без использования привязки к виду индексирования

Если мы ходим иметь работающий код, который не будет приязан к тому, с какого значения индекса начинается индексация массива (в Julia возможны массивы специального типа, в которых индексация может начинаться не только с 1, но и с любого другого целого значения), то следует пользоваться специальными встроенными функциями:
`first`, `firstindex`, `last`, `lastindex`, `nextindex` и специальными зарезервированными словами `begin`, `end`, которые в контексте индексного выражения обозначают первый и последний индекс массива, соответственно. Например:

```julia
function bubblesort!(a)
    n = length(a)
    for k in 1:n-1
        istranspose = false
        for i in firstindex(a):lastindex(a)-k
            if a[i]>a[i+1]
                a[i], a[i+1] = a[i+1], a[i]
                istranspose = true
            end
        end
        if istranspose == false
            break
        end
    end
    return a
end
```

## Срезы массивов

Любой массив имеет какое-то число измерений (индексов) dim. В частности, если `dim=1`, то такой массив мы называем вектором, если `dim=2`, то - матрицей.
Всё сказанное в этом параграфе относится к массивам любого числа измерений, но для определенности будем считать, что `dim=2`.

Срезом массива называют массив, состоящий из элементов данного массива, и получаемый из данного массива с помощью указания соответствующих диапазонов индексов, и/или векторных индексов. Более подробно рассмотрим это на конкретном примере.

Пусть, например,

```julia
A = [10 20 30 40 50
     60 70 80 90 95
     15 25 35 45 55
     65 75 85 96 97]

```

Тогда, например,

```julia
    A[2,3] - это число 70 
    A[2,3] = 0 - число 70 заменяется значением 0
```

Это не срезы, это примеры использования обычных индексов. Рассмотрим примеры срезов массива `A`:

```julia
A[[1,3],[2,4,5,2]] - это срез, представляющий собой массив, составленный из элементов массива A:

[ A[1,2] A[1,4] A[1,5] A[1,2]
  A[1,2] A[1,4] A[1,5] A[1,2]]
```

(если строки матрицы записаны одна под другой, то в записи матрицы ставить разделитель строк ";" не обязательно)

Как видим, срез может включать и повторяющиеся элементы исходного массива.

Срез формируется путем **копирования** элементов данного массива в новую область памяти.

Задача. Написать функцию, формирующую срез заданной матрицы по заданным наборам индексов - имеется ввиду без использования конструкции A[I,J], где I,J - два заданных набора индексов (в примере выше, например, I=[1,2], J=[2,4,5,2]).

Решение.

```julia
function slice(A::Matrix,I::Vectot{Int},J::Vector{Int})
    B=Matrix{eltype(A)}(undef,length(I),length(J))
    for i in I
        for j in J
            B[i,j]=A[I[i],J[j]]
        end
    end
    return B
end
```

Пояснение. Встроенная функция eltype(A) возвращает тип элементов массива A (вязыке Julia скалярные значения совместимы с массивами размера "1 на 1", поэтому данную функцию можно применять не только к маасивам, но и к скалярам).
Конструктор `Matrix{Type}` - это синоним `Array{Type,2}` (Type - это имя какого-либо типа), также как и `Vector{Type}` - это синоним `Array{Type,1}`. Запись `Matrix{eltype(A)}(undef,length(I),length(J))` - означает, что вызывается конструктор `Matrix{Type}` со своими фактическими аргументами. При формировании числовых массивов первый аргумент всегда имеет значение `undef', что означает, что элементы массива не инициализируются (их значения являются, как принято говорить, просто "информационным мусором"). Два последних аргумента - определяют размер создаваемого массива; допускается передавать размеры массива также в виде одного кортежа.

ЗАМЕЧАНИЕ. Иногда, когда имеется некоторый массив `A` и требуется сформировать неинициализированный массив `B` того же типа и размера, то вместо `B=Array{eltype(A),ndims(A)}(undef,size(A))` можно воспользоваться специальной встроенной функцией `B=similar(A)`.

Использовать для той же цели функцию `zeros` (или ей подобную, например, `ones`) не целесообразно, поскольку операция инициализации массива - не "бесплатная". Однако если требуется именно инициализация массива, то наряду с функциями `zeros` и `ones` имеется встроенная функция `fill`, обеспечивающая инициализациию всех элементов массива каким-либо заданным значением, напрример: `fill(value, size)`, где `value` - заданное значение, `size` - кортеж, содержащий размеры создаваемого массива. При этом тип массива будет совпадать с типом значения  `value`; допускается также размеры массива передавать не в кортеже, а отдельными значениями, например, в случаее двумерноного массива: `fill(value, size_1, size_2)`.

## Ссылки на срезы массива, функция view (макрос @view)

В языке Julia любой срез является копией некоторой части заданного массива, т.е. другим массивом.
Однако часто требуется получить ссылку на часть заданного массива, причем так, чтобы работать с этой ссылкой формально можно было бы так же как с отдельным массивом. Для этой цели в языке Julia пердусмотрена специальная функция `view`. Например,

```julia
A=[10 20 30
   40 50 60
   70 80 90]
   
B = view(A,:,2) 

# B - это ссылка на срез A[:,2]:

B[1]=0
println(A)
  [10  0 30
   40 50 60
   70 80 90]
```

Вместо вызовов функции `view` более удобно пользоваться соответствующим макросом `@view`, например:

```julia
B = @view A[:,2]
```

результат будет в точности тот же.

## Сортировка всех строк матрицы (каждая сторка сортируется по отдельности)

На базе разработанных выше функций сортировки одномерных массивов реализовать соответствующие функции для сортировки столбцов матрицы (воспользоваться механизмом множественной диспетчеризации)

```julia
function bubblesort!(A::Matrix)
    for j in size(A,2)
        bubblesort!(@view A[:,j]) 
    end
    return A
end

bubblesort(A::Matrix)=bubblesort!(deepcopy(A))
```

```julia
function bubblesortperm!(A::Matrix)
    indexes=Matrix{Int}(undef,size(A)) 
    for j in size(A,2)
        indexes[:,j]=bubblesortperm!(@view A[:,j]) 
    end
    return indexes
end

bubblesortperm(A::Matrix)=bubblesortperm!(deepcopy(A))
```

ЗАМЕЧАНИЕ. Поскольку срез матрицы в виде ее строки - это в формальном отношении двумерный а не одномерный массив, то для сортировки строк матрицы мезанизм множественной диспетчеризации работать не будет (вместо этого возникнет рекурсия). Поэтому, для того чтобы аналогичным образом сортировать сторки матрицы, ее сначала нужно транспонировать, затем использовать сортировку столбцов, затем снова транспонировать.

## Cортировка массива по ключу

Пусть имеется последователность (массив) объектов некоторого тпипа.
Ключем будем называть любую вещественно-значную функцию, определенную на объектах данного типа.

Например, если объекты - это числовые векторы, то примерами ключея будут: сумма элементов вектора, максимальное значение абсолютных величин вектора, число нулевых элементов вектора, длина вектора.

Сортировка вектора по значениям ключа

```julia
function sortkey!(a, key_values)
    ind = sortperm!(key_values)
    return @view a[ind]
end
```

Пусть, например, требуется отсортировать столбцы матрицы A в порядке неубывания сумм их элементов.

```julia
B=vcat(sortkey([@viev A[:,j] for j in 1:size(A,2)], sum(A,dims=2))...)

```

Здесь функция `sortkey!([@viev A[:,j] for j in 1:size(A,2)], sum(A,dims=2))` возвращает вектор, составленный из столбцов матрицы (перечисленных в нужном порядке). Чтобы из этих столбцов теперь снова получить матрицу, нужно выполнить операцию горизонтальной конкатенации отдельных столбцов. Для этого может быть использована встроенная функция vcat, аргументами кторорой должны быть столбцы матрицы. Чтобы извлечь столбцы из содержащего их вектора использована операция "...".

Аналогично, пусть, например, требуется отсортировать столбцы матрицы A в порядке неубывания сумм **абсолютных величин** их элементов.

```julia
B=vcat(sortkey!([@viev A[:,j] for j in 1:size(A,2)], sum(abs, A, dims=2))...)

```

Здесь функция sum использована как функция высшего порядка, первый аргумент которой в данном случае имеет функциональный тип (Function) (эта функция имеет несколько вариантов использования, см. help).

Или, пусть, например, требуется отсортировать столбцы матрицы A в порядке неубывания числа содержащихся в них нулевых элементов.

```julia[
a = @viev A[:,j] for j in 1:size(A,2)]
keyvalues = [length(findall(A[:,j] .== 0)) for j in 1:size(A,2)]
B = vcat(sortkey!(a, keyvalues)
```

Здесь `[length(findall(A[:,j] .== 0)) for j in 1:size(A,2)]` - это так называемое списковое включение, т.е. в данном частном случае с помощью конструкции спискового включения формируется вектор, длина которго равна число столбцов матрицы `A`, и каждый элемент которого равен числу нулей в соответствующем столбце матрицы `A`. Число нулей в j-ом столбце матрицы получается здесь с помощью выражения `length(findall(A[:,j] .== 0)`, в котором аргументом функции `length` фактически является массив, составленный из индексов нулевых элементов вектор-столбца `A[:,j]`. Этот массив форммируется с помощью встроенной функции `findall`, кторая в данном случае (эта функция имеет много разных вариантов использования, см. help) своим аргументом имеет массив (вектор), сосотавленный из логических значений (типа `Bool`). Этот вектор логических значений получается как результат выполнения операции `A[:,j] .== 0` поэлементного (для этого перед == поставлена точка) сравнения j-го столбца матрицы A с 0.

## Сортировка методом подсчета (сортировка за линейное время)

В случае, если значения элементов сортируемого массива (a), являются элементами некоторого заранее известного относительно небольшого множества (`values`), то отсортировать такой массив можно за O(n) операций следующим образом. Будем считать, что множество значений values представлено одноименным отсортированным массивом или диапазоном (тут вжно только, чтобы выполнялось условие `values[i] < values[i+1]`).

Сначала надо перебрать все элементы в массиве `a` и подсчитать, сколько раз встретилось каждое значение из данного набора значений `values`, а затем остается только в мвссив 'a' поместь значение `values[1]` подсчитанное число раз, затем - `values[2]`, и т.д., и, наконец, - `values[end]`.

```julia
function calcsort!(a, values)
    num_val = zeros(Int, size(values))
    for v in a
        num_val[indexvalue(v,values)] += 1
    end
    k=1
    for i in eachindex(values)
        for j in 1:num_val[i]
            a[k] = values[i]
            k+=1
        end
    end
    return a
end
```

Здесь вспомогательная функция indexvalue(v, values) возвращает индекс значения `v` в наборе значений `values`. Реализация этой функции зависит от способа представления набора значений `values`.

В случае, если `values` - это диапазон целых чисел, то возможна следующая реализация.

```julia
indexvalue(v, values::UnionRange) = v - values[1] + 1
```

В случае, если `values` - это отсортированный вектор значений, то возможна следующая реализация.

```julia
indexvalue(v, values::Vector) = findfirst(v, values)
```

### Сортировка массива по заданным значениям ключа методом подсчета

Писть имеется вектор значений некоторого типа и соответствующий вектор значений ключа. Пусть множество всех возможных значений ключа принадлежит некоторму заданному диапазону целых чисел, причем длина этого диапазона не зависит от числа элементов заданного вектора и много меньше последнего. Тогда для сотрировки этого вектора по заданным значениям ключа можно применить сортировку подсчетом.

```julia
function calcsortkey(a, key_series, key_values)
    vector_vector_indexes = calcsortindexes(key_series, key_values)
    j=1
    for vector_indexes in vector_vector_indexes  
        for i in vector_indexes
            b[j] = a[i]
            j+=1
        end
    end
    return b
end
```

Здесь вспомогательная функция  `calcsortindexes(keyvalues,values)` возвращает вектор, длина которого равна числу элементов в `values`, а значениями этого возвращаемого вектора будут вектра, содержащие индексы сортируемого вектора `a`, равных очередному значеию из множества `values`. В каком-то смысле (в смысле применений) данная функция также соотносится с функцией calcsort, как соотносятся между собой встроенные функции `sortperm` и `sort`.

```julia
function calcsortindexes(key_series, key_values)
    vector_vector_indexes = fill(Vector{Int}[], size(key_values) # вектор соразмерный с values, состоящий из пустых векторов типа Vector{Int}
    for i in eachindex(key_series)
        push!(vector_vector_indexes[indexvalue(key_series[i], key_values), i)
    end

    return vector_vector_indexes
end
```

Например, если дана матрица, в которой число строк ограничено (относително небольшое), а число столбцов может быть достаточно большим, то для сортировки её столбцов в порядке неубывания числа нулей в столбцах будет целесообразно воспользоваться сортировкой подсчетом количеств (числа нулей в данном слуае). В этом случае ассимптотическая оценка вычислительной сложности алгоритма может быть `O(n)`, где n - число столбцов матрицы.

Задача: реализовать сортировку столбцов матрицы по значению в них числа нулей для данного случая.

Указание. Чтобы иметь возможность применить для решения этой задачи разработанную здесь функцию `calcsortkey(a, key_series, key_values)`, потребуется сначала преобразовать заданную матрицу в вектор, элементами которого будут столбцы этой матрицы (далее к этому вектору нужно будет применить функцию `calcsortkey(a, key_series, keyvalues)`, предварительно сформировав вектор `key_series`, а затем, снова преобразовать уже отсортированный вектор, состоящий из столбцов, в матрицу).
