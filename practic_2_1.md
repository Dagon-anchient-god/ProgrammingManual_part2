# ПРАКТИКОЕ ЗАНЯТИЕ 1

## Функции сортировки в Julia

Изучить с помощью встроенной помощи (help?>) назначение и способы использования следующих встроенных функций julia: 

- sort!(a), sort(a), sortperm!(a), sortperm(a)
- issorted
- zeros
- size, length
- findall, finfirst
- collect
- view, @view
- Array, Vector, Matrix
- copy, deepcopy
- similar

## Сортирвка методом "пузырька"

По аналогии со встроенными функциями сортировки можно реализовать следующие 4 вида функций сортировки на базе агоритма сортировки методом "пузырька".

```julia
function bubblesort!(a)
    n = length(a)
    for k in 1:n-1
        istranspose = false
        for i in 1:n-k
            if a[i]>a[i+1]
                a[i], a[i+1] = a[i+1], a[i]
                istranspose = true
            end
        end
        if istranspose == false
            break
        end
    end
    return a
end
```

```julia
bubblesort(a)=bubblesort!(deepcopy(a))
```

```julia
function bubblesortperm!(a)
    n = length(a)
    indexes = collect(1:n)
    for k in 1:n-1
        istranspose = false
        for i in 1:n-k
            if a[i]>a[i+1]
                a[i],a[i+1]=a[i+1],a[i]
                indexes[i],indexes[i+1]=indexes[i+1],indexes[i]
                istranspose = true
            end
        end
        if istranspose == false
            break
        end
    end
    return indexes
end
```

```julia
bubblesortperm(a)=bubblesortperm!(deepcopy(a))
```

## Срезы массивов, копии и ссылки, функция view (макрос @view)

Любой массив имеет какое-то число измерений (индексов) dim. В частности, если `dim=1`, то такой массив мы называем вектором, если `dim=2`, то - матрицей.
Всё сказанное в этом параграфе относится к массивам любого числа измерений, но для определенности будем считать, что `dim=2`.

Срезом массива называют массив, состоящий из элементов данного массива, и получаемый из данного массива с помощью указания соответствующих диапазонов индексов, и/или векторных индексов. Более подробно рассмотрим это на конкретном примере.

Пусть, например,

```julia
A = [10 20 30 40 50
     60 70 80 90 95
     15 25 35 45 55
     65 75 85 96 97]

```

Тогда, например,

```julia
    A[2,3] - это число 70 
    A[2,3] = 0 - число 70 заменяется значением 0
```

Это не срезы, это примеры использования обычных индексов. Рассмотрим примеры срезов массива `A`:

```julia
A[[1,3],[2,4,5]] - это срез, представляющий соб
```

## Сортировка всех строк матрицы (каждая сторка сортируется по отдельности)

На базе разработанных выше функций сортировки одномерных массивов реализовать соответствующие функции для сортировки столбцов матрицы (воспользоваться механизмом множественной диспетчеризации)

```julia
function bubblesort!(A::Matrix)
    for j in size(A,2)
        bubblesort!(@view A[:,j]) 
    end
    return A
end

bubblesort(A::Matrix)=bubblesort!(deepcopy(A))
```

```julia
function bubblesortperm!(A::Matrix)
    indexes=Matrix{Int}(undef,size(A)) 
    for j in size(A,2)
        indexes[:,j]=bubblesortperm!(@view A[:,j]) 
    end
    return indexes
end

bubblesortperm(A::Matrix)=bubblesortperm!(deepcopy(A))
```

ЗАМЕЧАНИЕ. Поскольку срез матрицы в виде ее строки - это в формальном отношении двумерный а не одномерный массив, то для сортировки строк матрицы мезанизм множественной диспетчеризации работать не будет (вместо этого возникнет рекурсия). Поэтому, для того чтобы аналогичным образом сортировать сторки матрицы, ее сначала нужно транспонировать, затем использовать сортировку столбцов, затем снова транспонировать.

Задача: реализовать функцию, выполняющую транспонирование (transpose - соответствующая встроенная функция julia)
(Указание: сначала разобраться с алгоритмом перестановки элементов одномерного массива в обратном порядке. В julia имеется соответствующая встроенная функция - reverse)

## Cортировка массива по ключу

Пусть имеется последователность (массив) объектов некоторого тпипа.
Ключем будем называть любую вещественно-значную функцию, определенную на объектах данного типа.

Например, если объекты - это числовые векторы, то примерами ключея будут: сумма элементов вектора, максимальное значение абсолютных величин вектора, число нулевых элементов вектора, длина вектора.

Сортировка вектора по значениям ключа

```julia
function sortkey!(a, key_values)
    ind = sortperm!(key_values)
    return @view a[ind]
end
```

Пусть, например, требуется отсортировать столбцы матрицы A в порядке неубывания сумм их элементов.

```julia
B=vcat(sortkey([@viev A[:,j] for j in 1:size(A,2)], sum(A,dims=2))...)

```

Здесь функция `sortkey!([@viev A[:,j] for j in 1:size(A,2)], sum(A,dims=2))` возвращает вектор, составленный из столбцов матрицы (перечисленных в нужном порядке). Чтобы из этих столбцов теперь снова получить матрицу, нужно выполнить операцию горизонтальной конкатенации отдельных столбцов. Для этого может быть использована встроенная функция vcat, аргументами кторорой должны быть столбцы матрицы. Чтобы извлечь столбцы из содержащего их вектора использована операция "...".

Аналогично, пусть, например, требуется отсортировать столбцы матрицы A в порядке неубывания сумм **абсолютных величин** их элементов.

```julia
B=vcat(sortkey!([@viev A[:,j] for j in 1:size(A,2)], sum(abs, A, dims=2))...)

```

Здесь функция sum использована как функция высшего порядка, первый аргумент которой имеет функциональный тип (Function).

Или, пусть, например, требуется отсортировать столбцы матрицы A в порядке неубывания числа содержащихся в них нулевых элементов.

```julia[
a = @viev A[:,j] for j in 1:size(A,2)]
keyvalues = [length(findall(A[:,j] .== 0) for j in 1:size(A,2)])
B = vcat(sortkey!(a, keyvalues)

```

## Перестановка элементов в массиве без использования дополнительного массива

Пусть имеется  некоторый одномерный массива A, и требуется переставить элементы A в порядке, определяемом вектором заданной перестановки его индексов ind.

Для этого в Julia можно просто написать A[ind], чем ранее мы уже воспользовались. Однако возникает вопрос, а как это реализуется на более низком уровне?

В принципе это можно сделать следующими  двумя способами:

- копировать элементы исходного массива A в новый массив B в требуемом порядке, определяемом вектором индексов ind, а затем присвоить A=B
- переставлять элементы непосредственно в массиве A, не используюя дополнительного массива B
  
Второй способ позволяет не расходовать дополнительную память (для больших массивов это может быть критично).

Какой из этих двух способов реализован в Julia - этот вопрос требует специального исследования. Скорее всего, реализован первый способ, поскольку срезы допускают не только перестановку индексов. В частности индексы в наборе могут быть повторящимися, а в этом случае речь не может идти только о циклических перестановках сответствующих значений в массиве. При этом проверка, является ли данный набор индексов некоторой перестановкой индексов исходного массива или нет, реализуется на основе сортировки, т.е. является довольно затратной.

Задача: реализовать этот второй способ перестановки элементов массива.

Указание. Если говорить алгебраическим языком, то, как известно, любая перестановка индексов представляется в виде произведения  некоторого числа независимых циклов (циклических перестановок). Понятно, что каждую такую независимую циклическую перестановку лего реализовать без использования дополнительного массива. Проблема состоит лишь в том, чтобы не пропустить никакую циклическую перестановку. Но для этого, при выполнении очередной циклической перестановки, можно,например, изменять знак каждого уже "использованного" индекса на отрицательный, и тогда, когда в векторе ind больше не останется положительных элементов, это будет означать, что все требуемые перестановки выполнены.

## Сортировка методом подсчета (сортировка за линейное время)

В случае, если значения элементов сортируемого массива (a), являются элементами некоторого заранее известного относительно небольшого множества (`values`), то отсортировать такой массив можно за O(n) операций следующим образом. Будем считать, что множество значений values представлено одноименным отсортированным массивом или диапазоном (тут вжно только, чтобы выполнялось условие `values[i] < values[i+1]`).

Сначала надо перебрать все элементы в массиве `a` и подсчитать, сколько раз встретилось каждое значение из данного набора значений `values`, а затем остается только в мвссив 'a' поместь значение `values[1]` подсчитанное число раз, затем - `values[2]`, и т.д., и, наконец, - `values[end]`.

```julia
function calcsort!(a, values)
    num_val = zeros(Int, size(values))
    for v in a
        num_val[indexvalue(v,values)] += 1
    end
    k=1
    for i in eachindex(values)
        for j in 1:num_val[i]
            a[k] = values[i]
            k+=1
        end
    end
    return a
end
```

Здесь вспомогательная функция indexvalue(v, values) возвращает индекс значения `v` в наборе значений `values`. Реализация этой функции зависит от способа представления набора значений `values`.

В случае, если `values` - это диапазон целых чисел, то возможна следующая реализация.

```julia
indexvalue(v, values::UnionRange) = v - values[1] + 1
```

В случае, если `values` - это отсортированный вектор значений, то возможна следующая реализация.

```julia
indexvalue(v, values::Vector) = findfirst(v, values)
```

### Сортировка массива по заданным значениям ключа методом подсчета

Писть имеется вектор значений некоторого типа и соответствующий вектор значений ключа. Пусть множество всех возможных значений ключа принадлежит некоторму заданному диапазону целых чисел, причем длина этого диапазона не зависит от числа элементов заданного вектора и много меньше последнего. Тогда для сотрировки этого вектора по заданным значениям ключа можно применить сортировку подсчетом.

```julia
function calcsortkey(a, key_series, key_values)
    vector_vector_indexes = calcsortindexes(key_series, key_values)
    j=1
    for vector_indexes in vector_vector_indexes  
        for i in vector_indexes
            b[j] = a[i]
            j+=1
        end
    end
    return b
end
```

Здесь вспомогательная функция  `calcsortindexes(keyvalues,values)` возвращает вектор, длина которого равна числу элементов в `values`, а значениями этого возвращаемого вектора будут вектра, содержащие индексы сортируемого вектора `a`, равных очередному значеию из множества `values`. В каком-то смысле (в смысле применений) данная функция также соотносится с функцией calcsort, как соотносятся между собой встроенные функции `sortperm` и `sort`.

```julia
function calcsortindexes(key_series, key_values)
    vector_vector_indexes = fill(Vector{Int}[], size(key_values) # вектор соразмерный с values, состоящий из пустых векторов типа Vector{Int}
    for i in eachindex(key_series)
        push!(vector_vector_indexes[indexvalue(key_series[i], key_values), i)
    end

    return vector_vector_indexes
end
```

Например, если дана матрица, в которой число строк ограничено (относително небольшое), а число столбцов может быть достаточно большим, то для сортировки её столбцов в порядке неубывания числа нулей в столбцах будет целесообразно воспользоваться сортировкой подсчетом количеств (числа нулей в данном слуае). В этом случае ассимптотическая оценка вычислительной сложности алгоритма может быть `O(n)`, где n - число столбцов матрицы.

Задача: реализовать сортировку столбцов матрицы по значению в них числа нулей для данного случая.
Указание. Чтобы иметь возможность применить для решения этой задачи разработанную здесь функцию `calcsortkey(a, key_series, key_values)`, потребуется сначала преобразовать заданную матрицу в вектор, элементами которого будут столбцы этой матрицы (далее к этому вектору нужно будет применить функцию `calcsortkey(a, key_series, keyvalues)`, предварительно сформировав вектор `key_series`, а затем, снова преобразовать уже отсортированный вектор, состоящий из столбцов, в матрицу).
