# ПРАКТИЧЕСКОЕ ЗАНЯТИЕ 2

Задания

- Написать функцию `sortkey!(a, key_values)`, получающую на вход некоторый вектор `a`, и соответствующий вектор `keyvalues` ключевых значений элементов вектора `a`, осуществляющую сортировку вектора `a` по ключевым значениям его элементов, и возвращающую ссылку на вектор `a`. (Для сортировки вектора ключевых значений можно востпользоваться одной из разработанных в пункте 1 функций, или соответствующей встроенной функцией).

- С использованием разработанной функции `sortkey!` написать функцию высшего порядка, с тем же именем `sortkey!`, но вместо массива ключевых значений получающую на вход ключевую функцию и массив элементов некоторого типа, на множестве значений которых должна быть определена данная ключевая функция.

```julia
function sortkey!(f::Function, a)
    indperm=sortperm!(f.(a))
    return a(indperm)
end
```

- С использованием этой последней функции отсортировать столбцы какой-либо заданной числовой матрицы в порядке
а) не убывания их сумм
б) не убывания числа нулей в них

- Написать функцию `calcsort`, реализующую сортировку методом подсчета числа значений. Рассмотреть 2 варианта функции (2 метода - в терминологии Julia): в первом варианте возможные значения элементов сортируемого массива задаются некоторым диапазоном, во втором - некоторым отсортированным массивом (вектором).

- Применить эту разработанную функцию для сортировки столбцов матрицы по числу находящихся в них нулей (в каком случае сортировка подсчетом даст выигрыш по сравнению с любым другим методом сортировки?).

- Написать функции `insertsort!`, `insertsort`, `insertsortperm`, `insertsortperm!` (по аналогии с пунктом 1) реализующие алгоритм сортировки вставками

- Дополнить функцию `insrtsort!` процедурой "быстрого поиска".

Указание. Предварительно написать функцию `quicsearch(iter,val)`, реализующую быстрый поиск. Эта функция должна получать некоторый итерируемый объект, содержащий предварительно отсортированную последовательность, и некоторое значение, и возвращать кортеж 2-х значений: первое значение должно быть типа `Bool` (`true` - если `val in itr`, и `false` - в противном случае), а второе значение - это индекс элемента itr, имеющий искомое значение, если таковое имеется, или - это номер позиции в `itr`, на которую следовало бы поместить значение val, чтобы сохранить отсортированность последовательности в `itr`.

Идея быстрого поиска основана на том, что последовательность, среди элементов которой ищется заданное значение, заранее отсортирована. Тогда, есле на каждом шаге алгоритма брать "середину" последовательности и искомое значение сравнивать с ней, то либо, при совпадении сравниваемых значений, поиск будет закончен, либо область дальнейшего поиска может быть сокращена вдвое (путем отбрасывания той половины последовательности, в которой искомое значение завндомо отсутствует - здесь используется факт отсортированности последовательности).
